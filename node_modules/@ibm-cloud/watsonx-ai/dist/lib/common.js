"use strict";
/**
 * (C) Copyright IBM Corp. 2020.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformStreamToStringStream = exports.LineTransformStream = exports.transformStreamToObjectStream = exports.ObjectTransformStream = exports.StreamTransform = exports.getSdkHeaders = void 0;
/* eslint-disable max-classes-per-file */
const os = require("os");
const stream_1 = require("stream");
const pkg = require('../package.json');
/**
 * Get the request headers to be sent in requests by the SDK.
 *
 * If you plan to gather metrics for your SDK, the User-Agent header value must
 * be a string similar to the following:
 * autogen-node-sdk/0.0.1 (lang=node.js; os.name=Linux; os.version=19.3.0; node.version=v10.15.3)
 *
 * In the example above, the analytics tool will parse the user-agent header and
 * use the following properties:
 * "autogen-node-sdk" - the name of your sdk
 * "0.0.1"- the version of your sdk
 * "lang=node.js" - the language of the current sdk
 * "os.name=Linux; os.version=19.3.0; node.version=v10.15.3" - system information
 *
 * Note: It is very important that the sdk name ends with the string `-sdk`,
 * as the analytics data collector uses this to gather usage data.
 */
function getSdkHeaders(serviceName, serviceVersion, operationId) {
    const sdkName = 'autogen-node-sdk';
    const sdkVersion = pkg.version;
    const osName = os.platform();
    const osVersion = os.release();
    const nodeVersion = process.version;
    const headers = {
        'User-Agent': `${sdkName}/${sdkVersion} (lang=node.js; os.name=${osName} os.version=${osVersion} node.version=${nodeVersion})`,
    };
    return headers;
}
exports.getSdkHeaders = getSdkHeaders;
const stringToObj = (chunk) => {
    const obj = {};
    chunk.forEach((line) => {
        const index = line.indexOf(': ');
        const key = line.substring(0, index);
        const value = line.substring(index + 2);
        if (key === 'id') {
            obj[key] = Number(value);
        }
        else if (key === 'event') {
            obj[key] = String(value);
        }
        else if (key === 'data') {
            obj[key] = JSON.parse(`${value}`);
        }
    });
    return Object.keys(obj).length > 0 ? obj : null;
};
class StreamTransform extends stream_1.Transform {
    constructor() {
        super({ readableObjectMode: true, writableObjectMode: false });
        this.buffer = '';
    }
}
exports.StreamTransform = StreamTransform;
class ObjectTransformStream extends StreamTransform {
    _transform(chunk, _encoding, callback) {
        this.buffer += chunk.toString();
        const parts = this.buffer.split('\n');
        if (parts.indexOf('') !== parts.length - 2 && parts.indexOf('') !== -1) {
            while (parts.length > 0) {
                const newObj = parts.splice(0, parts.indexOf('') + 1);
                const obj = stringToObj(newObj);
                if (obj)
                    this.push(obj);
            }
            this.buffer = '';
        }
        else if (parts[parts.length - 1] !== '') {
            this.buffer = parts.join('\n');
        }
        else {
            const obj = stringToObj(parts);
            this.buffer = '';
            if (obj)
                this.push(obj);
        }
        callback();
    }
    _flush(callback) {
        if (this.buffer) {
            const parts = this.buffer.split('\n');
            const obj = stringToObj(parts);
            this.push(obj);
        }
        callback();
    }
}
exports.ObjectTransformStream = ObjectTransformStream;
function transformStreamToObjectStream(apiResponse) {
    return __awaiter(this, void 0, void 0, function* () {
        const readableStream = stream_1.Readable.from(apiResponse.result).pipe(new ObjectTransformStream());
        return readableStream;
    });
}
exports.transformStreamToObjectStream = transformStreamToObjectStream;
class LineTransformStream extends StreamTransform {
    _transform(chunk, _encoding, callback) {
        this.buffer += chunk.toString();
        const lines = this.buffer.split('\n');
        this.buffer = lines.pop();
        lines.forEach((line) => this.push(line));
        callback();
    }
    _flush(callback) {
        if (this.buffer) {
            this.push(this.buffer);
        }
        callback();
    }
}
exports.LineTransformStream = LineTransformStream;
function transformStreamToStringStream(apiResponse) {
    return __awaiter(this, void 0, void 0, function* () {
        const readableStream = stream_1.Readable.from(apiResponse.result).pipe(new LineTransformStream());
        return readableStream;
    });
}
exports.transformStreamToStringStream = transformStreamToStringStream;
//# sourceMappingURL=common.js.map